#include <cstdio>
#include <cstdlib>
#include <cmath>

void func(double *y, double *ys, double t) { // функция вычисления правых частей уравнений
    ys[0] = y[1]; // ys[1]-первая производная; ys[2]-вторая и т.д.
    ys[1] = y[2]; // t-независимый аргумент
    ys[2] = 5 + t * t - y[0] - 3. * y[1] - 2. * y[2];
}

void Adams(
        void f(double *y, double *ys, double x),
        double *y, // Массив размера n значений зависимых переменных
        int n, // Массив размера n значений производных
        double tn, // Начало интервала интегрирования
        double tk, // Конец интервала интегрирования
        int m, // Начальное число разбиений отрезка интегрирования
        double eps) // Относительная погрешность интегрирования
{

    double *k1, *k2, *k3, *k4; // Для метода Рунге-Кутта
    double *q0, *q1, *q2, *q3; // Значение производных Для метода Адамса
    double *ya; // Временный массив
    double *y0, *y1, *y2, *y3; // Значения функции для метода Адамса
    double h; // Шаг интегрирования
    double xi; // Текущее значение независимой переменной
    double eps2; // Для оценки погрешности
    double dq2, dq1, dq0, d2q1, d2q0, d3q0; // приращения
    int flag = 0; // 0, пока идёт первый просчёт
    int i, j; // Индексы

    if (m < 4) m = 4; // Минимум 4 отрезка

    if (tn >= tk) {
        printf("nНеправильные аргументыn");
        abort(); // Неправильные аргументы
    }

    // Выделяем память для массивов с переменными
    if ((k1 = (double *) malloc((4 + 4 + 4 + 1) * n * sizeof(double))) == 0) {
        printf("nОшибка распределения памятиn");
        abort(); // Прервать, если не удалось
    }

    k2 = k1 + n;
    k3 = k2 + n;
    k4 = k3 + n;

    y0 = k4 + n;
    y1 = y0 + n;
    y2 = y1 + n;
    y3 = y2 + n;


    ya = y3 + n;

    // Для метода Адамса

    q0 = ya + n;
    q1 = q0 + n;
    q2 = q1 + n;
    q3 = q2 + n;

    h = (tk - tn) / m; // Шаг

    eps = fabs(eps); // Абсолютное значение погрешности

    start: // Отсюда начинаются вычисления

    xi = tn; // Начало промежутка
    for (j = 0; j < n; j++) y0[j] = y[j]; // Копируем его в y0
    f(y0, q0, xi); // Заполняем q0, основываясь на значениях из y0
    for (j = 0; j < n; j++) q0[j] *= h; // Делаем q0

    xi += h; // Следующий шаг
    for (i = 0; i < 3; i++) 

    {
        f(&y0[i * n], k1, xi); // Вычислим f(xi, yi) = k1 / h
           for (j = 0; j < n; j++) {
            k1[j] *= h; // k1
            ya[j] = y0[i * n + j] + k1[j] / 2.;
        }

        f(ya, k2, xi + (h / 2.)); // Вычислим f(xi,yi) = k2 / h
        for (j = 0; j < n; j++) { // Вычислим наконец-то k2
            k2[j] *= h;
            ya[j] = y0[i * n + j] + k2[j] / 2.; // И один из аргументов для функции
        } // вычисления k3

        f(ya, k3, xi + h / 2.); // Вычислим f(xi,yi) = k3 / h

        for (j = 0; j < n; j++) {
            k3[j] *= h; // Вычислим наконец-то k3
            ya[j] = y0[i * n + j] + k3[j]; // И один из аргументов для функции
        } // вычисления k4

        f(ya, k4, xi + h); // Вычислим f(xi,yi) = k4 / h
        for (j = 0; j < n; j++) k4[j] *= h;
        for (j = 0; j < n; j++)
            y0[(i + 1) * n + j] = y0[i * n + j] + (k1[j] + 2. * k2[j] + 2 * k3[j] + k4[j]) / 6.;
        f(&y0[(i + 1) * n], &q0[(i + 1) * n], xi); // qi = f (xi, yi);
        for (j = 0; j < n; j++) q0[((i + 1) * n) + j] *= h;
        xi += h; // Следующий шаг }

        for (j = 0; j < n; j++) { // Все приращения

            dq2 = q3[j] - q2[j];
            dq1 = q2[j] - q1[j];
            dq0 = q1[j] - q0[j];

            d2q1 = dq2 - dq1;
            d2q0 = dq1 - dq0;

            d3q0 = d2q1 - d2q0;

            ya[j] = y3[j] + (q3[j] + (dq2 / 2.) + (5. * d2q1 / 12.) + (3. * d3q0 / 8.));

            y0[j] = y1[j];
            y1[j] = y2[j];
            y2[j] = y3[j];
            y3[j] = ya[j];

            q0[j] = q1[j];
            q1[j] = q2[j];
            q2[j] = q3[j];

        }
        f(y3, q3, xi); // q3 = f (xi, y3);

        for (j = 0; j < n; j++) q3[j] *= h; // Вычислить q3

        xi += h;

        if (xi < tk) goto again; // Да.
        if (flag == 0)
            flag = 1; // Сравнивать уже будет с чем

        else {
            for (j = 0; j < n; j++) {
                eps2 = fabs(((y3[j] - y2[j]) / y2[j]));
                if (eps2 > eps) break;
            }

            if (j == n){
                for (j = 0; j < n; j++) y[j] = y3[j];
                free(k1); // Освобождаем память
                return; // Возвращаемся в main
            }
        }
        h /= 2.; // Уменьшить шаг
        goto start; // Повторить расчёт сначала, с новыми параметрами
    }
}

int main() {
    double y[3], xs, xe;

    int i;

    y[0] = 1.;
    y[1] = 0.1;
    y[2] = 0.; // Начальные условия

    xs = .0;
    xe = .1; // Начало интегрирования

    printf("x = %5.3lg, y(%4.2lg) = %10.3lgn\n", xs, xs, y[0]);

    for (i = 0; i < 20; i++) {
        Adams(func, y, 3, xs, xe, 10, 1.e-3);
        xs += 0.1;
        xe += 0.1;
        printf("x = %5.3lg, y(%4.2lg) = %10.3lgn\n", xs, xs, y[0]);
    }
    system("pause");
    return 0;
}
